---
title: "Using and adding IAMC data checks"
author: "Jan Philipp Dietrich"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using and adding IAMC data checks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Purpose and Functionality

The iamc R package is a collection of R tools provided by the Integrated Assessment Modeling Consortium (IAMC) for data consistency checks. It can be used to make sure that a data set is in line with rules set by a given project. This rules can be for instance a given naming convention or unit conventions for variables, but also qualitative measures such as that certain variables lie between certain bounds. Besides that the data can be compared to given validation data.

## Components
Below follows a brief overview about the essential components. 

###Input data
You can upload the results of your model runs in .rda format and store them in the iamc/data folder. When later we speak about input data it will be these files. 

###Configuration 
The configuration file describes the allowed structure and values for the input data (e.g. allowed variables, units, min, max etc.). The configuration is given as .csv file and should be stored in iamc/inst/extdata. 
The default configuration is that of the CDLINKS convention. As will be shown below any other configuration can be specified.  

###Validation
All data can be validated against historical and other reference data if available. A collection of global historical and other reference data is provided by the package and used as default validation data. The results of the validation can be viewed in a output pdf, see below for more details on how to do so.  
If you need to inspect the currently given default validation data please type str(sysdata\$validation) @all -> stimmt natürlich nicht, was müsse die leute tippen/ oder wenigstens die location geben sysdata$XY
@all -> where should an alternative validation file be (which folder), which format.
@all -> Validation: Im Code fliegt überall noch val="IAMC" rum, ist das jetzt in der Konfig noch sinnvoll?
Im Prinzip muss es nirgends mehr als Parameter übergeben werden? Sehe ich das richtig?
Kann die Valdata jetzt nur noch aus der sysdata kommen, oder kann man noch validation data hinterlegen?

###Pre-checks
To also allow to check the basic structure of the data to be checked the user can also define pre-checks. These checks make sure, that the data can actually be processed without breaking the system. 
To define your own pre-check you can add a R-script to the folder iamc/R/. Only requirement is that the name starts with "precheck" (e.g. "preCheckMyNewCheck.R""). Any R script starting with "precheck" will be automatically detected and added to the required list of checks. 
@all -> What if pre-checks fail, will check still be processed? Should not actually. I know I asked earlier, but i cannot remember the answer. 
(@Jan ist die Location eigentlich egal, wo die checks liegen (in unserem fall /iamc/R), weil die Funktionen eh im Environment registriert sind und damit von überall gefunden werden?)

###Checks
The actual checks are then used to investigate the values of the uploaded data. E.g. if values lie within a given range defined by a min and max, etc ...
Same as for prechecks - to define your own check you can add a R-script to the folder iamc/R/. Only requirement is that the name starts with "check" (e.g. "CheckMyNewCheck.R""). Any R script starting with "check" will be automatically detected and added to the required list of checks. 


###Output-PDF
For each run of consistency checks the user can request a pdf which summarizes the results of the checks and the validation. 
Otherwise results are just output to the console


## A simple example

The package comes with a small example data set `example_REMIND` supposed to be checked against a configuration 'example_CFG'. This is a strongly reduced example for demonstration purposes (to be found in the iamc/inst/extdata folder). If no configuration is explicitly assigned the default from the CDLINKS convention is taken. This file can also be found in the iamc/inst/extdata folder.
To show the functionality of the package some mistakes have been introduced into the example data set. To see these mistakes you can feed the input data set to the check function `iamCheck`:

```{r, echo=TRUE}
library(iamc)
iamCheck(example_REMIND, cfg="example_CFG")
```

This returns information about the checks performed and the problems found in the data. In this example the prechecks are reporting information about variables: e.g. in "preCheckIllegalVariables" we specified a test, that checks if the input data in "example_REMIND" has variables that do not occur in the configuration file "example_CFG", thus are illegal. The test "preCheckMissingVariables" indentifies all variables that are specified in the configuration-file but are not occuring in the input data. 
The checks "checkMin" and "checkMax" test if the values of the input data correspond to the minimal and maximal values specified in the configuration files. 


## Customize project settings

Explicitly setting `cfg="example_CFG"` in the example above makes sure that the data is analyzed based on a set of rule specified in "example_CFG.csv" and not based on the default "CDLINKS.csv". Thus, to use specific project settings you have to explicitly assign a configuration to "cfg". The file must be given in "csv" format and stored in "iamc/inst/extdata". Another way is to load existing cfg project settings and customize them. In the following example we take the existing example_CFG config and introduce the new variable `Population_OtherName` that is not in the data by renaming the existing variable `Population`. The second example sets a new maximum value for the variable 'FE' to 200:

```{r, echo=TRUE}
# first example
# load cfg
cfg <- iamProjectConfig("example_CFG")
# modify cfg
cfg$variable[cfg$variable=="Population"] <- "Population_OtherName"
# run check with new cfg
iamCheck(example_REMIND, cfg=cfg)

# second example
# load cfg
cfg <- iamProjectConfig("example_CFG")
# modify cfg
cfg$max[cfg$variable=="FE"] <- 200
# run check with new cfg
iamCheck(example_REMIND, cfg=cfg)
```

## Validate data against historical and other reference data

All data can be validated against historical and other reference data if available. A collection of global historical and other reference data is provided by the package and used as default validation data (i.e. 'val="IAMC"). The data and reference data are plotted into one graph. As well the consitency is checked by some indicators like the absolute value, the gradient and the trend. These results are summarised in a traffic light system. The results of the validation are stored in the 'pdf=validation.pdf' if a name for the pdf is given by the user.  

```{r, echo=TRUE}
# provide a name for the pdf so that the validation is run 
iamCheck(example_REMIND, pdf="validation.pdf", cfg="example_CFG")

```

## Adding own checks

It is possible and encouraged to add own checks. All check functions should have a name starting with "check" or "precheck". Like this they will be automatically detected and added to the list of checks. The checks may only use parameters available in the parameter list of iamCheck, which are currently x (the provided input data to be tested as quitte object), mx (the same data as magclass object), cfg (the project configuration) and val (the validation data). 

The function needs to return a list of two objects: a character "message" which is the message showing up at the end of the test with the place holder "%#" for the number of elements for which the test failed, and secondly a character vector "failed" identifying the objects (e.g. their names as character) for which the test failed.

By default iamCheck will only look for checks which are available within the package, but with the argument `globalenv = TRUE` it will also search the global environment for functions. 

To add for instance a unit check, you can write a function `checkUnits` following the rules mentioned above and run `iamCheck` with `globalenv = TRUE`:

```{r, echo=TRUE}
library(iamc)

checkUnits <- function(x, cfg) {
  x_var_unit <- unique(paste(x$variable, x$unit, sep=" | unit: "))
  cfg_var_unit <- unique(paste(cfg$variable, cfg$unit, sep=" | unit: "))
  failed <- x_var_unit[!(x_var_unit %in% cfg_var_unit)]
  return(list(message="%# variables are reported in the wrong unit",
              failed=failed))
}

iamCheck(example_REMIND, cfg="example_CFG", globalenv=TRUE)

# run again with modified cfg to trigger unit warning
example2 <-example_REMIND
levels(example2$unit)[2] <- "weird_unit"

iamCheck(example2, cfg="example_CFG", globalenv=TRUE)

```

As soon as the new check is working it would be nice if you could add it to the package so that others can use it as well.



